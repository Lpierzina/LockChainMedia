<!DOCTYPE html> 
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">   
    <title>MediaSecureNFT - LockChain's Media Secure Platform</title>
    <!-- Include Web3.js library -->
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.4/dist/web3.min.js"></script>
    <!-- Include Coinbase Wallet SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@coinbase/wallet-sdk@3.4.1/dist/coinbase-wallet.min.js"></script>
    <!-- Include Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <style>
        /* LockChain Theme Colors */
        :root {
            --lockchain-blue: #0E7AFE;
            --lockchain-light-blue: #0071BC;
            --lockchain-gray: #F5F5F5;
            --lockchain-white: #FFFFFF;
            --text-color: #333333;
        }

        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            background-color: var(--lockchain-gray);
            color: var(--text-color);
            position: relative; /* To position the fingerprint background correctly */
            overflow-x: hidden; /* Prevent horizontal scroll caused by absolute positioning */
        }

        /* Static Transparent Fingerprint Background */
        .fingerprint-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('path-to-your-fingerprint-image.png'); /* Replace with your fingerprint image path */
            background-size: cover; /* Adjusts the image to cover the entire background */
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.1; /* Adjust opacity for desired transparency */
            pointer-events: none; /* Allow clicks to pass through */
            z-index: -1; /* Place behind all other content */
        }

        header {
            background-color: var(--lockchain-blue);
            color: var(--lockchain-white);
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            z-index: 1; /* Ensure header stays above fingerprint */
        }

        header .logo {
            font-size: 24px;
            font-weight: bold;
        }

        nav a {
            color: var(--lockchain-white);
            text-decoration: none;
            margin-left: 15px;
            font-size: 16px;
        }

        nav a:hover {
            text-decoration: underline;
        }

        main {
            padding: 40px;
            text-align: center;
            position: relative;
            z-index: 1; /* Ensure main content stays above fingerprint */
        }

        .intro-section {
            background-color: var(--lockchain-white);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            max-width: 800px;
            margin: 0 auto 40px auto;
            text-align: left;
        }

        .intro-section h2 {
            color: var(--lockchain-blue);
            margin-bottom: 15px;
        }

        .intro-section h3 {
            color: var(--lockchain-blue);
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .intro-section p {
            font-size: 18px;
            line-height: 1.6;
            color: var(--text-color);
        }

        .intro-section ul {
            list-style-type: disc;
            padding-left: 20px;
        }

        /* Flex Container for Spiral and Color Mapping */
        .spiral-and-color {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin-top: 30px;
            flex-wrap: wrap; /* Allows wrapping on smaller screens */
        }

        .nft-container {
            position: relative;
            width: 500px;
            height: 500px;
            background-color: var(--lockchain-white);
            border: 2px solid var(--lockchain-blue);
            border-radius: 50%;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            overflow: hidden; /* Ensure spiral stays within the circle */
            margin: 10px;
        }

        .nft-container svg {
            width: 100%;
            height: 100%;
        }

        /* Style for Dynamic Color Mapping */
        #colorCode {
            margin-left: 20px;
            max-width: 250px;
            color: var(--text-color);
            display: none; /* Hidden by default */
        }

        #colorCode h3 {
            color: var(--lockchain-blue);
            margin-bottom: 10px;
        }

        #colorCode ul {
            list-style-type: none;
            padding-left: 0;
        }

        #colorCode li {
            margin-bottom: 5px;
            font-size: 16px;
        }

        footer {
            background-color: var(--lockchain-light-blue);
            color: var(--lockchain-white);
            text-align: center;
            padding: 15px;
            position: fixed;
            width: 100%;
            bottom: 0;
            z-index: 1; /* Ensure footer stays above fingerprint */
        }

        /* Responsive Design */
        @media (max-width: 800px) {
            .spiral-and-color {
                flex-direction: column;
                align-items: center;
            }

            #colorCode {
                margin-left: 0;
                margin-top: 20px;
                max-width: 80%;
            }
        }

        /* Button Styles */
        .btn {
            background-color: var(--lockchain-blue);
            color: var(--lockchain-white);
            border: none;
            padding: 12px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 5px;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .btn:hover {
            background-color: var(--lockchain-light-blue);
            transform: translateY(-2px);
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        /* Disconnect Button */
        #disconnectButton {
            background-color: #ff4d4d; /* Red color for disconnect */
        }

        #disconnectButton:hover {
            background-color: #ff1a1a;
        }

        /* Input Fields */
        input[type="file"] {
            margin-bottom: 20px;
        }

        /* Hash Output */
        #hashOutput {
            font-weight: bold;
            margin: 20px 0;
            word-break: break-all;
            color: var(--lockchain-blue);
            font-size: 16px;
        }

        /* Receipt */
        #receipt {
            border: 2px solid var(--lockchain-blue);
            padding: 20px;
            margin-top: 30px;
            border-radius: 8px;
            background-color: #e6f0ff;
            display: none;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            text-align: left;
        }

        #receipt h3 {
            margin-bottom: 15px;
            color: var(--lockchain-blue);
        }

        /* Loading Overlay */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(30, 66, 159, 0.8); /* Semi-transparent background */
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000; /* Ensure it overlays other elements */
        }

        #loadingOverlay .loader {
            border: 12px solid #f3f3f3; /* Light grey */
            border-top: 12px solid var(--lockchain-white); /* White */
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1.5s linear infinite;
            margin-bottom: 20px;
        }

        #loadingOverlay p {
            color: #fff;
            font-size: 18px;
            text-align: center;
            max-width: 80%;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Connect Wallet Section */
        #walletSection {
            margin-top: 30px;
        }

        #walletAddress {
            margin-top: 10px;
            font-weight: bold;
            color: var(--lockchain-blue);
            font-size: 16px;
        }

        /* Button Fee Note */
        #feeNote {
            font-size: 14px;
            color: #555;
            margin-top: 5px;
        }

        /* Image Preview Styling */
        #imagePreview {
            margin-top: 20px;
            max-width: 100%;
            max-height: 300px;
            border: 2px solid var(--lockchain-blue);
            border-radius: 8px;
        }
    </style>
</head>
<body>

    <!-- Static Transparent Fingerprint Background -->
    <div class="fingerprint-background">
        <!-- No SVG or animated paths here -->
        <!-- Ensure you have a high-quality, transparent fingerprint image -->
    </div>

    <!-- Header Section -->
    <header>
        <div class="logo">LockChain's MediaSecureNFT</div>
        <nav>
            <a href="#">Home</a>
            <a href="#">About</a>
            <a href="#">Mint NFT</a>
            <a href="#">Contact</a>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <!-- Introduction Section -->
        <div class="intro-section">
            <h2>Welcome to LockChain's Media Secure Platform</h2>
            <p>
                In today's digital age, securing your valuable media files is paramount. LockChain's Media Secure website leverages the power of blockchain technology to provide you with an immutable proof of ownership for your digital assets. By hashing your media files and issuing a unique NFT with a color-matching fingerprint, we ensure that your digital content remains authentic and tamper-proof.
            </p>
            <h3>Understanding Hashing and Your NFT Fingerprint</h3>
            <p>
                <strong>Hashing</strong> is a process that converts your media file into a fixed-size string of characters, which appears random. This unique string, known as a <strong>hash</strong>, acts like a digital fingerprint for your file. Just as no two fingerprints are identical, no two hashes (for different files) will be the same.
            </p>
            <p>
                When you register your media file on our platform, we:
                <ul>
                    <li>🔒 <strong>Hash Your File:</strong> Convert your media into a unique hash.</li>
                    <li>🎨 <strong>Generate a Visual Spiral:</strong> Create a colorful spiral visualization based on your hash.</li>
                    <li>🖼️ <strong>Mint an NFT:</strong> Issue a Non-Fungible Token (NFT) that links to your media's hash and its visual spiral.</li>
                </ul>
            </p>
            <p>
                This process ensures that your media's ownership is verifiable and immutable on the blockchain, providing you with peace of mind and security.
            </p>
            <h3>Color Mapping</h3>
            <p>
                Each color in the spiral represents a specific hexadecimal character (0-9, a-f) from your media's hash. Here's how each color maps to a character:
            </p>
            <ul>
                <li><span style="color: #FF0000;">🔴 Red</span> : 0</li>
                <li><span style="color: #FFA500;">🟠 Orange</span> : 1</li>
                <li><span style="color: #FFFF00;">🟡 Yellow</span> : 2</li>
                <li><span style="color: #008000;">🟢 Green</span> : 3</li>
                <li><span style="color: #0000FF;">🔵 Blue</span> : 4</li>
                <li><span style="color: #4B0082;">🟣 Indigo</span> : 5</li>
                <li><span style="color: #EE82EE;">🟣 Violet</span> : 6</li>
                <li><span style="color: #A52A2A;">🟤 Brown</span> : 7</li>
                <li><span style="color: #808080;">⚫ Gray</span> : 8</li>
                <li><span style="color: #000000;">⚫ Black</span> : 9</li>
                <li><span style="color: #00FFFF;">🟡 Aqua</span> : a</li>
                <li><span style="color: #FF00FF;">🟣 Fuchsia</span> : b</li>
                <li><span style="color: #800000;">🟤 Maroon</span> : c</li>
                <li><span style="color: #808000;">🟤 Olive</span> : d</li>
                <li><span style="color: #008080;">🟢 Teal</span> : e</li>
                <li><span style="color: #000080;">🔵 Navy</span> : f</li>
            </ul>
        </div>

        <!-- Spiral Visualization and Dynamic Color Mapping -->
        <div class="spiral-and-color">
            <div class="nft-container">
                <!-- Combined SVG (Image + Spiral) will be injected here by JavaScript -->
                <svg id="combined-svg" width="500" height="500"></svg>
            </div>
            <!-- Color Code Mapping (Revealed After Hashing) -->
            <div id="colorCode">
                <h3>Color Code Mapping</h3>
                <ul>
                    <li><span style="color: #FF0000;">🔴 Red</span> : 0</li>
                    <li><span style="color: #FFA500;">🟠 Orange</span> : 1</li>
                    <li><span style="color: #FFFF00;">🟡 Yellow</span> : 2</li>
                    <li><span style="color: #008000;">🟢 Green</span> : 3</li>
                    <li><span style="color: #0000FF;">🔵 Blue</span> : 4</li>
                    <li><span style="color: #4B0082;">🟣 Indigo</span> : 5</li>
                    <li><span style="color: #EE82EE;">🟣 Violet</span> : 6</li>
                    <li><span style="color: #A52A2A;">🟤 Brown</span> : 7</li>
                    <li><span style="color: #808080;">⚫ Gray</span> : 8</li>
                    <li><span style="color: #000000;">⚫ Black</span> : 9</li>
                    <li><span style="color: #00FFFF;">🟡 Aqua</span> : a</li>
                    <li><span style="color: #FF00FF;">🟣 Fuchsia</span> : b</li>
                    <li><span style="color: #800000;">🟤 Maroon</span> : c</li>
                    <li><span style="color: #808000;">🟤 Olive</span> : d</li>
                    <li><span style="color: #008080;">🟢 Teal</span> : e</li>
                    <li><span style="color: #000080;">🔵 Navy</span> : f</li>
                </ul>
            </div>
        </div>

        <!-- Connect MetaMask and Coinbase Wallet -->
        <div id="walletSection">
            <button class="btn" id="connectMetaMaskButton" onclick="connectMetaMask()">Connect MetaMask</button>
            <button class="btn" id="connectCoinbaseButton" onclick="connectCoinbaseWallet()">Connect Coinbase Wallet</button>
            <button class="btn" id="disconnectButton" onclick="disconnectWallet()" disabled>Disconnect Wallet</button>
            <p id="walletAddress">Not connected</p>
        </div>

        <!-- Hash and Register Document -->
        <h3>Hash Your Media File</h3>
        <input type="file" id="fileInput" accept="image/*,video/*,audio/*,.pdf" /><br>
        <button class="btn" onclick="hashDocument()">Hash Document</button>

        <!-- Image Preview -->
        <img id="imagePreview" src="#" alt="Image Preview" style="display: none;"/>

        <p id="hashOutput"></p>

        <button class="btn" id="registerButton" onclick="registerHashOnBlockchain()" disabled>
            Register Hash on Blockchain (Fee: <span id="buttonFee">0.01 ETH</span>)
        </button>
        <p id="feeNote">Note: A fee of <span id="feeAmount">0.01 ETH</span> is required to register your document.</p>

        <!-- Receipt -->
        <div id="receipt">
            <h3>Transaction Receipt</h3>
            <p id="receiptContent"></p>
        </div>
    </main>

    <!-- Loading Overlay -->
    <div id="loadingOverlay">
        <div class="loader"></div>
        <p>Please wait, your transaction is being processed. This may take a couple of minutes.</p>
    </div>

    <!-- Footer Section -->
    <footer>
        &copy; 2024 LockChain's MediaSecureNFT. All rights reserved.
    </footer>

    <!-- JavaScript for Functionality -->
    <script>
        let web3;
        let contract;
        let account;
        let hashHex;
        let selectedProvider; // Tracks the current provider (MetaMask or Coinbase Wallet)
        
      
        
        
         // Contract ABI (Replace with your actual complete ABI)
        const contractABI = [
            {
                "type": "constructor",
                "inputs": [],
                "stateMutability": "nonpayable"
            },
            {
                "type": "function",
                "name": "MINT_FEE",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "stateMutability": "view"
            },
            {
                "type": "function",
                "name": "approve",
                "inputs": [
                    {
                        "name": "to",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "tokenId",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [],
                "stateMutability": "nonpayable"
            },
            {
                "type": "function",
                "name": "balanceOf",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "address",
                        "internalType": "address"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "stateMutability": "view"
            },
            {
                "type": "function",
                "name": "getApproved",
                "inputs": [
                    {
                        "name": "tokenId",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "address",
                        "internalType": "address"
                    }
                ],
                "stateMutability": "view"
            },
            {
                "type": "function",
                "name": "isApprovedForAll",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "operator",
                        "type": "address",
                        "internalType": "address"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "stateMutability": "view"
            },
            {
                "type": "function",
                "name": "mintNFT",
                "inputs": [
                    {
                        "name": "mediaHash",
                        "type": "string",
                        "internalType": "string"
                    }
                ],
                "outputs": [],
                "stateMutability": "payable"
            },
            {
                "type": "function",
                "name": "name",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "string",
                        "internalType": "string"
                    }
                ],
                "stateMutability": "view"
            },
            {
                "type": "function",
                "name": "owner",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "address",
                        "internalType": "address"
                    }
                ],
                "stateMutability": "view"
            },
            {
                "type": "function",
                "name": "ownerOf",
                "inputs": [
                    {
                        "name": "tokenId",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "address",
                        "internalType": "address"
                    }
                ],
                "stateMutability": "view"
            },
            {
                "type": "function",
                "name": "renounceOwnership",
                "inputs": [],
                "outputs": [],
                "stateMutability": "nonpayable"
            },
            {
                "type": "function",
                "name": "safeTransferFrom",
                "inputs": [
                    {
                        "name": "from",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "to",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "tokenId",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [],
                "stateMutability": "nonpayable"
            },
            {
                "type": "function",
                "name": "safeTransferFrom",
                "inputs": [
                    {
                        "name": "from",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "to",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "tokenId",
                        "type": "uint256",
                        "internalType": "uint256"
                    },
                    {
                        "name": "data",
                        "type": "bytes",
                        "internalType": "bytes"
                    }
                ],
                "outputs": [],
                "stateMutability": "nonpayable"
            },
            {
                "type": "function",
                "name": "setApprovalForAll",
                "inputs": [
                    {
                        "name": "operator",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "approved",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "outputs": [],
                "stateMutability": "nonpayable"
            },
            {
                "type": "function",
                "name": "supportsInterface",
                "inputs": [
                    {
                        "name": "interfaceId",
                        "type": "bytes4",
                        "internalType": "bytes4"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "bool",
                        "internalType": "bool"
                    }
                ],
                "stateMutability": "view"
            },
            {
                "type": "function",
                "name": "symbol",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "string",
                        "internalType": "string"
                    }
                ],
                "stateMutability": "view"
            },
            {
                "type": "function",
                "name": "tokenCounter",
                "inputs": [],
                "outputs": [
                    {
                        "name": "",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "stateMutability": "view"
            },
            {
                "type": "function",
                "name": "tokenURI",
                "inputs": [
                    {
                        "name": "tokenId",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [
                    {
                        "name": "",
                        "type": "string",
                        "internalType": "string"
                    }
                ],
                "stateMutability": "view"
            },
            {
                "type": "function",
                "name": "transferFrom",
                "inputs": [
                    {
                        "name": "from",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "to",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "tokenId",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ],
                "outputs": [],
                "stateMutability": "nonpayable"
            },
            {
                "type": "function",
                "name": "transferOwnership",
                "inputs": [
                    {
                        "name": "newOwner",
                        "type": "address",
                        "internalType": "address"
                    }
                ],
                "outputs": [],
                "stateMutability": "nonpayable"
            },
            {
                "type": "function",
                "name": "withdraw",
                "inputs": [],
                "outputs": [],
                "stateMutability": "nonpayable"
            },
            // Events
            {
                "type": "event",
                "name": "Approval",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "approved",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "tokenId",
                        "type": "uint256",
                        "indexed": true,
                        "internalType": "uint256"
                    }
                ],
                "anonymous": false
            },
            {
                "type": "event",
                "name": "ApprovalForAll",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "operator",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "approved",
                        "type": "bool",
                        "indexed": false,
                        "internalType": "bool"
                    }
                ],
                "anonymous": false
            },
            {
                "type": "event",
                "name": "OwnershipTransferred",
                "inputs": [
                    {
                        "name": "previousOwner",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "newOwner",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    }
                ],
                "anonymous": false
            },
            {
                "type": "event",
                "name": "Transfer",
                "inputs": [
                    {
                        "name": "from",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "to",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "tokenId",
                        "type": "uint256",
                        "indexed": true,
                        "internalType": "uint256"
                    }
                ],
                "anonymous": false
            },
            {
                "type": "event",
                "name": "Withdrawal",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "address",
                        "indexed": true,
                        "internalType": "address"
                    },
                    {
                        "name": "amount",
                        "type": "uint256",
                        "indexed": false,
                        "internalType": "uint256"
                    }
                ],
                "anonymous": false
            },
            // Errors
            {
                "type": "error",
                "name": "ERC721IncorrectOwner",
                "inputs": [
                    {
                        "name": "sender",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "tokenId",
                        "type": "uint256",
                        "internalType": "uint256"
                    },
                    {
                        "name": "owner",
                        "type": "address",
                        "internalType": "address"
                    }
                ]
            },
            {
                "type": "error",
                "name": "ERC721InsufficientApproval",
                "inputs": [
                    {
                        "name": "operator",
                        "type": "address",
                        "internalType": "address"
                    },
                    {
                        "name": "tokenId",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ]
            },
            {
                "type": "error",
                "name": "ERC721InvalidApprover",
                "inputs": [
                    {
                        "name": "approver",
                        "type": "address",
                        "internalType": "address"
                    }
                ]
            },
            {
                "type": "error",
                "name": "ERC721InvalidOperator",
                "inputs": [
                    {
                        "name": "operator",
                        "type": "address",
                        "internalType": "address"
                    }
                ]
            },
            {
                "type": "error",
                "name": "ERC721InvalidOwner",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "address",
                        "internalType": "address"
                    }
                ]
            },
            {
                "type": "error",
                "name": "ERC721InvalidReceiver",
                "inputs": [
                    {
                        "name": "receiver",
                        "type": "address",
                        "internalType": "address"
                    }
                ]
            },
            {
                "type": "error",
                "name": "ERC721InvalidSender",
                "inputs": [
                    {
                        "name": "sender",
                        "type": "address",
                        "internalType": "address"
                    }
                ]
            },
            {
                "type": "error",
                "name": "ERC721NonexistentToken",
                "inputs": [
                    {
                        "name": "tokenId",
                        "type": "uint256",
                        "internalType": "uint256"
                    }
                ]
            },
            {
                "type": "error",
                "name": "OwnableInvalidOwner",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "address",
                        "internalType": "address"
                    }
                ]
            },
            {
                "type": "error",
                "name": "OwnableUnauthorizedAccount",
                "inputs": [
                    {
                        "name": "account",
                        "type": "address",
                        "internalType": "address"
                    }
                ]
            }
        ];
        // Contract address (Replace with your deployed contract address)
        const contractAddress = '0xc6040a3647441EeFf8086Dcc4239c293dde23B45';

  // Initialize Coinbase Wallet SDK
        const CoinbaseWalletSDK = window.CoinbaseWalletSDK.default;
        const coinbaseWallet = new CoinbaseWalletSDK({
            appName: "MediaSecureNFT",
            appLogoUrl: "https://your-logo-url.com/logo.png", // Optional: Replace with your app logo URL
            darkMode: false, // Optional: true for dark theme
        });

        // Sepolia RPC URL (Replace with your actual RPC URL if different)
        const COINBASE_RPC_URL = "https://eth-sepolia.alchemyapi.io/v2/DlloOg9phVabjuMziEUxAdV1a2veqPNU"; // Replace with your Alchemy API key
        const COINBASE_CHAIN_ID = 11155111; // Sepolia Test Network ID

        // Event listeners for wallet buttons
        document.getElementById('connectMetaMaskButton').addEventListener('click', connectMetaMask);
        document.getElementById('connectCoinbaseButton').addEventListener('click', connectCoinbaseWallet);

        // Function to connect MetaMask using window.ethereum
        async function connectMetaMask() {
            if (window.ethereum && window.ethereum.isMetaMask) {
                try {
                    console.log('Connecting to MetaMask...');
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    web3 = new Web3(window.ethereum);
                    const accounts = await web3.eth.getAccounts();
                    account = accounts[0];
                    selectedProvider = window.ethereum;
                    document.getElementById('walletAddress').innerText = 'Connected: ' + account;
                    contract = new web3.eth.Contract(contractABI, contractAddress);
                    console.log('Connected to MetaMask:', account);

                    // Disable MetaMask and Coinbase connect buttons
                    document.getElementById('connectMetaMaskButton').disabled = true;
                    document.getElementById('connectCoinbaseButton').disabled = true;
                    // Enable Disconnect Button
                    document.getElementById('disconnectButton').disabled = false;

                    // Check network
                    await checkNetwork();

                    // Fetch and display the current fee
                    await displayCurrentFee();

                    // Setup event listeners for MetaMask
                    setupEventListeners(window.ethereum);
                } catch (error) {
                    console.error('Error connecting to MetaMask:', error);
                    alert('Error connecting to MetaMask. Please check the console for details.');
                }
            } else {
                alert('MetaMask is not installed. Please install MetaMask and try again.');
            }
        }

        // Function to connect Coinbase Wallet using Coinbase Wallet SDK
        async function connectCoinbaseWallet() {
            try {
                console.log('Connecting to Coinbase Wallet...');
                const provider = coinbaseWallet.makeWeb3Provider(COINBASE_RPC_URL, COINBASE_CHAIN_ID);

                // Enable session (triggers QR Code modal)
                await provider.enable();

                web3 = new Web3(provider);
                const accounts = await web3.eth.getAccounts();
                account = accounts[0];
                selectedProvider = provider;
                document.getElementById('walletAddress').innerText = 'Connected: ' + account;
                contract = new web3.eth.Contract(contractABI, contractAddress);
                console.log('Connected to Coinbase Wallet:', account);

                // Disable MetaMask and Coinbase connect buttons
                document.getElementById('connectMetaMaskButton').disabled = true;
                document.getElementById('connectCoinbaseButton').disabled = true;
                // Enable Disconnect Button
                document.getElementById('disconnectButton').disabled = false;

                // Check network
                await checkNetwork();

                // Fetch and display the current fee
                await displayCurrentFee();

                // Setup event listeners for Coinbase Wallet
                setupEventListeners(provider);
            } catch (error) {
                console.error('Error connecting to Coinbase Wallet:', error);
                // Provide more specific feedback based on error type
                if (error.code === 4001) {
                    alert('Connection to Coinbase Wallet was rejected by the user.');
                } else if (error.message.includes('unsupported chain')) {
                    alert('Connected to an unsupported network. Please switch to Sepolia.');
                } else {
                    alert('An unexpected error occurred while connecting to Coinbase Wallet.');
                }
            }
        }

        // Function to disconnect wallet
        async function disconnectWallet() {
            try {
                if (selectedProvider) {
                    // If Coinbase Wallet provider has a disconnect method, call it
                    if (selectedProvider.close) {
                        await selectedProvider.close();
                    }

                    // If MetaMask provider, no need to explicitly disconnect
                    // Users can disconnect from MetaMask manually if desired
                }

                // Reset Web3 and related variables
                web3 = null;
                account = null;
                contract = null;
                selectedProvider = null;

                // Update UI
                document.getElementById('walletAddress').innerText = 'Not connected';
                document.getElementById('disconnectButton').disabled = true;
                document.getElementById('connectMetaMaskButton').disabled = false;
                document.getElementById('connectCoinbaseButton').disabled = false;
                document.getElementById('registerButton').disabled = true;
                document.getElementById('hashOutput').innerText = '';
                document.getElementById('receipt').style.display = 'none';
                // Clear any stored hash
                hashHex = null;
                // Hide the color code mapping
                document.getElementById('colorCode').style.display = 'none';
                // Clear spiral visualization
                document.getElementById('spiral-svg').innerHTML = '';
                // Hide image preview
                document.getElementById('imagePreview').style.display = 'none';

                alert('Wallet has been disconnected.');
            } catch (error) {
                console.error('Error disconnecting wallet:', error);
                alert('Error disconnecting wallet. Please check the console for details.');
            }
        }

        // Function to fetch and display the current fee
        async function displayCurrentFee() {
            if (!contract) {
                alert('Smart contract is not initialized.');
                return;
            }
            try {
                const feeInWei = await contract.methods.MINT_FEE().call();
                console.log('Fetched fee in Wei:', feeInWei);
                const feeInEth = web3.utils.fromWei(feeInWei, 'ether');
                console.log('Converted fee to ETH:', feeInEth);
                document.getElementById('buttonFee').innerText = feeInEth + ' ETH';
                document.getElementById('feeAmount').innerText = feeInEth + ' ETH'; // Update feeAmount
            } catch (error) {
                console.error('Error fetching current fee:', error);
                alert('Error fetching current fee from the contract. Check console for details.');
            }
        }

        // Function to hash the selected media file
        async function hashDocument() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a media file.');
                return;
            }

            try {
                // Display image preview if the file is an image
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = document.getElementById('imagePreview');
                        img.src = e.target.result;
                        img.style.display = 'block';
                    }
                    reader.readAsDataURL(file);
                } else {
                    // Hide image preview for non-image files
                    document.getElementById('imagePreview').style.display = 'none';
                }

                const arrayBuffer = await file.arrayBuffer();
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                hashHex = '0x' + hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                document.getElementById('hashOutput').innerText = `Document Hash: ${hashHex}`;

                // Enable the register button
                document.getElementById('registerButton').disabled = false;

                // Generate the spiral visualization
                generateSpiral(hashHex.slice(2)); // Remove '0x' prefix

                // Reveal the color code mapping
                document.getElementById('colorCode').style.display = 'block';
            } catch (error) {
                console.error('Error hashing the document:', error);
                alert('Error hashing the document. See console for details.');
            }
        }

        // Function to register the hashed document on the blockchain
        async function registerHashOnBlockchain() {
            if (!web3 || !account || !contract) {
                alert('Please connect your wallet first.');
                return;
            }

            if (!hashHex) {
                alert('Please hash a media file first.');
                return;
            }

            const mediaHash = hashHex;

            try {
                // Fetch the current fee from the contract
                const feeInWei = await contract.methods.MINT_FEE().call();
                console.log('Fee in Wei:', feeInWei);

                // Show the loading overlay
                document.getElementById('loadingOverlay').style.display = 'flex';

                // Send the transaction to mintNFT
                const receipt = await contract.methods.mintNFT(mediaHash).send({
                    from: account,
                    value: feeInWei, // Use the dynamic fee
                });

                console.log('Transaction receipt:', receipt);
                generateReceipt(mediaHash, account, receipt);

                // After successful transaction, generate SVG and upload to Pinata
                await generateAndUploadSVG();
            } catch (error) {
                console.error('Error registering hash on blockchain:', error);
                alert('Error registering hash on blockchain. See console for details.');
            } finally {
                // Hide the loading overlay
                document.getElementById('loadingOverlay').style.display = 'none';
            }
        }

       

        // Function to check if the user is connected to the Sepolia network
        async function checkNetwork() {
            if (!web3) {
                console.error('Web3 is not initialized.');
                return;
            }
            try {
                const chainId = await web3.eth.getChainId();
                console.log('Connected chain ID:', chainId);
                if (chainId !== COINBASE_CHAIN_ID) { // Sepolia's chain ID
                    try {
                        await selectedProvider.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0xaa36a7' }], // 11155111 in hexadecimal
                        });
                        console.log('Switched to Sepolia Test Network.');
                    } catch (switchError) {
                        // This error code indicates that the chain has not been added to MetaMask
                        if (switchError.code === 4902) {
                            alert('Please add the Sepolia network to your wallet.');
                        } else if (switchError.code === 4001) {
                            alert('Network switch rejected by user.');
                        } else {
                            console.error('Error switching network:', switchError);
                        }
                    }
                } else {
                    console.log('Connected to Sepolia Test Network.');
                }
            } catch (error) {
                console.error('Error checking network:', error);
            }
        }

        // Function to setup event listeners for account and network changes
        function setupEventListeners(provider) {
            if (provider.on) {
                provider.on('accountsChanged', (accounts) => {
                    if (accounts.length === 0) {
                        // Wallet is locked or the user has not connected any accounts
                        disconnectWallet();
                    } else {
                        account = accounts[0];
                        document.getElementById('walletAddress').innerText = 'Connected: ' + account;
                    }
                });

                provider.on('chainChanged', (chainId) => {
                    // Handle the new chain
                    console.log('Chain changed to:', chainId);
                    checkNetwork();
                });

                provider.on('disconnect', (code, reason) => {
                    console.log('Disconnected:', code, reason);
                    disconnectWallet();
                });
            }
        }

        // Listen for account and network changes in MetaMask
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', function (accounts) {
                if (accounts.length === 0) {
                    // MetaMask is locked or the user has not connected any accounts
                    disconnectWallet();
                } else {
                    // Reload the page to update the connected account
                    window.location.reload();
                }
            });

            window.ethereum.on('chainChanged', function (chainId) {
                // Reload the page to switch to the new network
                window.location.reload();
            });
        }

        // Function to generate and display the transaction receipt
        function generateReceipt(mediaHash, account, receipt) {
            let tokenId = null;

            // Iterate through the logs to find the Transfer event
            if (receipt.events && receipt.events.Transfer && receipt.events.Transfer.returnValues) {
                tokenId = receipt.events.Transfer.returnValues.tokenId;
            }

            if (!tokenId) {
                // If Transfer event is not found in receipt, alert the user
                alert('Transaction successful, but could not retrieve Token ID.');
                return;
            }

            // Construct the Etherscan link for the NFT
            const etherscanLink = `https://sepolia.etherscan.io/token/${contractAddress}?a=${tokenId}`;

            const timestamp = new Date().toLocaleString();
            const receiptContent = `
                <strong>Document Hash:</strong> ${mediaHash}<br>
                <strong>Registered By:</strong> ${account}<br>
                <strong>Date and Time:</strong> ${timestamp}<br>
                <strong>Token ID:</strong> ${tokenId}<br>
                <strong>View Your NFT:</strong> <a href="${etherscanLink}" target="_blank">Etherscan Link</a>
            `;
            document.getElementById('receiptContent').innerHTML = receiptContent;
            document.getElementById('receipt').style.display = 'block';
        }

       // Function to generate the spiral visualization based on the hash
        function generateSpiral(hash) {
            const spiralSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            spiralSVG.setAttribute("width", "500");
            spiralSVG.setAttribute("height", "500");
            spiralSVG.setAttribute("xmlns", "http://www.w3.org/2000/svg");

            const centerX = 250; // Half of width
            const centerY = 250; // Half of height

            // Spiral parameters
            const a = 4.5; // Controls the distance between loops
            const b = 0.12; // Controls the tightness of the spiral
            const numPoints = hash.length;
            const angleIncrement = 0.5; // Radians between points

            // Color mapping for hexadecimal characters (0-9, a-f)
            const digitColors = {
                '0': '#FF0000', // Red
                '1': '#FFA500', // Orange
                '2': '#FFFF00', // Yellow
                '3': '#008000', // Green
                '4': '#0000FF', // Blue
                '5': '#4B0082', // Indigo
                '6': '#EE82EE', // Violet
                '7': '#A52A2A', // Brown
                '8': '#808080', // Gray
                '9': '#000000', // Black
                'a': '#00FFFF', // Aqua
                'b': '#FF00FF', // Fuchsia
                'c': '#800000', // Maroon
                'd': '#808000', // Olive
                'e': '#008080', // Teal
                'f': '#000080'  // Navy
            };

            const points = [];

            // Iterate over each character in the hash
            for (let i = 0; i < numPoints; i++) {
                const char = hash[i].toLowerCase(); // Ensure lowercase for a-f
                if (!digitColors[char]) continue; // Skip if not a valid hex character

                const theta = -i * angleIncrement; // Negative for clockwise
                const r = a * Math.exp(b * Math.abs(theta)); // Exponential spiral

                // Polar to Cartesian coordinates
                let x = centerX + r * Math.cos(theta);
                let y = centerY + r * Math.sin(theta);

                // Ensure the spiral stays within the SVG boundaries
                const maxRadius = 230; // Slightly less than half of SVG size to prevent overflow
                const currentRadius = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                if (currentRadius > maxRadius) {
                    const scale = maxRadius / currentRadius;
                    x = centerX + (x - centerX) * scale;
                    y = centerY + (y - centerY) * scale;
                }

                points.push({ x, y });

                // Create circle for each point
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", x);
                circle.setAttribute("cy", y);
                circle.setAttribute("r", 6); // Adjust radius as needed
                circle.setAttribute("fill", digitColors[char]);
                spiralSVG.appendChild(circle);
            }

            // Draw connecting lines (Bezier curves)
            for (let i = 0; i < points.length - 1; i++) {
                const start = points[i];
                const end = points[i + 1];

                // Control points for Bezier curves to enhance curvature
                const controlPoint1 = {
                    x: start.x + (end.x - start.x) / 2 + 10,
                    y: start.y - 20
                };
                const controlPoint2 = {
                    x: start.x + (end.x - start.x) / 2 + 10,
                    y: end.y - 20
                };

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                const d = `M ${start.x} ${start.y} C ${controlPoint1.x} ${controlPoint1.y}, ${controlPoint2.x} ${controlPoint2.y}, ${end.x} ${end.y}`;
                path.setAttribute("d", d);
                path.setAttribute("stroke", digitColors[hash[i + 1].toLowerCase()] || '#000000');
                path.setAttribute("stroke-width", "2");
                path.setAttribute("fill", "none");
                path.setAttribute("opacity", "0.6");
                spiralSVG.appendChild(path);
            }

            // Inject the spiral into the combined SVG container
            const combinedSVGContainer = document.getElementById('combined-svg');
            combinedSVGContainer.innerHTML = ''; // Clear previous content

            // Create background image element
            const imagePreview = document.getElementById('imagePreview');
            const imageSrc = imagePreview.src;

            if (imagePreview.style.display !== 'none') { // Ensure an image is loaded
                const imageElement = document.createElementNS("http://www.w3.org/2000/svg", "image");
                imageElement.setAttribute("href", imageSrc);
                imageElement.setAttribute("x", "0");
                imageElement.setAttribute("y", "0");
                imageElement.setAttribute("width", "500");
                imageElement.setAttribute("height", "500");
                imageElement.setAttribute("opacity", "0.2"); // Adjust opacity as needed
                combinedSVGContainer.appendChild(imageElement);
            }

            // Append the spiral SVG elements on top of the background image
            combinedSVGContainer.appendChild(spiralSVG);
        }
        // Function to generate and upload SVG to Pinata.cloud
        async function generateAndUploadSVG() {
            // Get the combined SVG content
            const combinedSVGContainer = document.getElementById('combined-svg');
            const combinedSVG = combinedSVGContainer.outerHTML;

            // Convert the combined SVG string to a Blob
            const svgBlob = new Blob([combinedSVG], { type: 'image/svg+xml' });
            const svgFile = new File([svgBlob], 'spiral_visualization.svg');

            // Upload the SVG file to Pinata.cloud via your backend
            try {
                const response = await fetch('/upload-to-pinata', { // Replace with your backend endpoint
                    method: 'POST',
                    body: createFormData(svgFile)
                });

                if (!response.ok) {
                    throw new Error(`Upload failed with status ${response.status}`);
                }

                const data = await response.json();
                console.log('Uploaded to Pinata:', data);
                alert('SVG successfully uploaded to IPFS via Pinata!');
            } catch (error) {
                console.error('Error uploading SVG to Pinata:', error);
                alert('Failed to upload SVG to Pinata. See console for details.');
            }
        }

        // Helper function to create FormData for file upload
        function createFormData(file) {
            const formData = new FormData();
            formData.append('file', file);
            return formData;
        }

        // Helper function to create FormData for file upload
        function createFormData(file) {
            const formData = new FormData();
            formData.append('file', file);
            return formData;
        }

        // Function to handle file upload to Pinata.cloud
        // This function should be implemented on your backend server
        // For security reasons, API keys should not be exposed on the frontend
        // Below is an example using Fetch API to send the file to your backend

        /*
            Backend Endpoint (/upload-to-pinata):
            - Receives the file via POST request
            - Uses Pinata's API to upload the file
            - Returns the IPFS hash or URL to the frontend
        */

        // Note: Implement the backend separately as detailed in the Backend Implementation section

    </script>

</body>
</html>
