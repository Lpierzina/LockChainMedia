<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaSecureNFT - LockChain's Media Secure Platform</title>
    <!-- Include Web3.js library -->
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.4/dist/web3.min.js"></script>
    <!-- Include Web3Modal library -->
    <script src="https://unpkg.com/web3modal@1.9.8/dist/index.min.js"></script>
    <!-- Include WalletConnect Provider -->
    <script src="https://unpkg.com/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
    <!-- Include Coinbase Wallet SDK -->
    <script src="https://unpkg.com/@coinbase/wallet-sdk@3.7.0/dist/coinbase-wallet-sdk.umd.min.js"></script>
    <!-- Include Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">

    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

    
    <style>
        /* LockChain Theme Colors */
        :root {
            --lockchain-blue: #0E7AFE;
            --lockchain-light-blue: #0071BC;
            --lockchain-gray: #F5F5F5;
            --lockchain-white: #FFFFFF;
            --text-color: #333333;
        }

        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            background-color: var(--lockchain-gray);
            color: var(--text-color);
        }

        header {
            background-color: var(--lockchain-blue);
            color: var(--lockchain-white);
            padding: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        header .logo {
            font-size: 24px;
            font-weight: bold;
        }

        nav a {
            color: var(--lockchain-white);
            text-decoration: none;
            margin-left: 15px;
            font-size: 16px;
        }

        nav a:hover {
            text-decoration: underline;
        }

        main {
            padding: 40px;
            text-align: center;
        }

        .intro-section {
            background-color: var(--lockchain-white);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            max-width: 800px;
            margin: 0 auto 40px auto;
            text-align: left;
        }

        .intro-section h2 {
            color: var(--lockchain-blue);
            margin-bottom: 15px;
        }

        .intro-section h3 {
            color: var(--lockchain-blue);
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .intro-section p {
            font-size: 18px;
            line-height: 1.6;
            color: var(--text-color);
        }

        .intro-section ul {
            list-style-type: disc;
            padding-left: 20px;
        }

        .nft-container {
            display: inline-block;
            position: relative;
            width: 500px;
            height: 500px;
            background-color: var(--lockchain-white);
            border: 2px solid var(--lockchain-blue);
            border-radius: 50%;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            margin-top: 20px;
            overflow: hidden; /* Ensure spiral stays within the circle */
        }

        .nft-container svg {
            width: 100%;
            height: 100%;
        }

        footer {
            background-color: var(--lockchain-light-blue);
            color: var(--lockchain-white);
            text-align: center;
            padding: 15px;
            position: fixed;
            width: 100%;
            bottom: 0;
        }

        /* Responsive Design */
        @media (max-width: 600px) {
            .nft-container {
                width: 300px;
                height: 300px;
            }

            header, footer {
                flex-direction: column;
            }

            nav a {
                margin: 10px 0 0 0;
            }

            .intro-section {
                padding: 20px;
            }

            .intro-section p {
                font-size: 16px;
            }
        }

        /* Button Styles */
        .btn {
            background-color: var(--lockchain-blue);
            color: var(--lockchain-white);
            border: none;
            padding: 12px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 5px;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .btn:hover {
            background-color: var(--lockchain-light-blue);
            transform: translateY(-2px);
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        /* Disconnect Button */
        #disconnectButton {
            background-color: #ff4d4d; /* Red color for disconnect */
        }

        #disconnectButton:hover {
            background-color: #ff1a1a;
        }

        /* Input Fields */
        input[type="file"] {
            margin-bottom: 20px;
        }

        /* Hash Output */
        #hashOutput {
            font-weight: bold;
            margin: 20px 0;
            word-break: break-all;
            color: var(--lockchain-blue);
            font-size: 16px;
        }

        /* Color Code Mapping */
        #colorCode {
            margin-top: 20px;
            text-align: left;
        }

        #colorCode h3 {
            color: var(--lockchain-blue);
            margin-bottom: 10px;
        }

        #colorCode ul {
            list-style-type: none;
            padding-left: 0;
        }

        #colorCode li {
            margin-bottom: 5px;
            font-size: 16px;
        }

        /* Receipt */
        #receipt {
            border: 2px solid var(--lockchain-blue);
            padding: 20px;
            margin-top: 30px;
            border-radius: 8px;
            background-color: #e6f0ff;
            display: none;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            text-align: left;
        }

        #receipt h3 {
            margin-bottom: 15px;
            color: var(--lockchain-blue);
        }

        /* Loading Overlay */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(30, 66, 159, 0.8); /* Semi-transparent background */
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000; /* Ensure it overlays other elements */
        }

        #loadingOverlay .loader {
            border: 12px solid #f3f3f3; /* Light grey */
            border-top: 12px solid var(--lockchain-white); /* White */
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1.5s linear infinite;
            margin-bottom: 20px;
        }

        #loadingOverlay p {
            color: #fff;
            font-size: 18px;
            text-align: center;
            max-width: 80%;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Connect Wallet Section */
        #walletSection {
            margin-top: 30px;
        }

        #walletAddress {
            margin-top: 10px;
            font-weight: bold;
            color: var(--lockchain-blue);
            font-size: 16px;
        }

        /* Button Fee Note */
        #feeNote {
            font-size: 14px;
            color: #555;
            margin-top: 5px;
        }
    </style>
</head>
<body>

    <!-- Header Section -->
    <header>
        <div class="logo">LockChain's MediaSecureNFT</div>
        <nav>
            <a href="#">Home</a>
            <a href="#">About</a>
            <a href="#">Mint NFT</a>
            <a href="#">Contact</a>
        </nav>
    </header>

    <!-- Main Content -->
    <main>
        <!-- Introduction Section -->
        <div class="intro-section">
            <h2>Welcome, welcome to LockChain's Media Secure Platform</h2>
            <p>
                In today's digital age, securing your valuable media files is paramount. LockChain's Media Secure website leverages the power of blockchain technology to provide you with an immutable proof of ownership for your digital assets. By hashing your media files and issuing a unique NFT with a color-matching fingerprint, we ensure that your digital content remains authentic and tamper-proof.
            </p>
            <h3>Understanding Hashing and Your NFT Fingerprint</h3>
            <p>
                <strong>Hashing</strong> is a process that converts your media file into a fixed-size string of characters, which appears random. This unique string, known as a <strong>hash</strong>, acts like a digital fingerprint for your file. Just as no two fingerprints are identical, no two hashes (for different files) will be the same.
            </p>
            <p>
                When you register your media file on our platform, we:
                <ul>
                    <li>üîí <strong>Hash Your File:</strong> Convert your media into a unique hash.</li>
                    <li>üé® <strong>Generate a Visual Fingerprint:</strong> Create a colorful spiral visualization based on your hash.</li>
                    <li>üñºÔ∏è <strong>Mint an NFT:</strong> Issue a Non-Fungible Token (NFT) that links to your media's hash and its visual fingerprint.</li>
                </ul>
            </p>
            <p>
                This process ensures that your media's ownership is verifiable and immutable on the blockchain, providing you with peace of mind and security.
            </p>
            <h3>Color Mapping</h3>
            <p>
                Each color in the fingerprint spiral represents a specific hexadecimal character (0-9, a-f) from your media's hash. Here's how each color maps to a character:
            </p>
            <ul>
                <li><span style="color: #FF0000;">üî¥ Red</span> : 0</li>
                <li><span style="color: #FFA500;">üü† Orange</span> : 1</li>
                <li><span style="color: #FFFF00;">üü° Yellow</span> : 2</li>
                <li><span style="color: #008000;">üü¢ Green</span> : 3</li>
                <li><span style="color: #0000FF;">üîµ Blue</span> : 4</li>
                <li><span style="color: #4B0082;">üü£ Indigo</span> : 5</li>
                <li><span style="color: #EE82EE;">üü£ Violet</span> : 6</li>
                <li><span style="color: #A52A2A;">üü§ Brown</span> : 7</li>
                <li><span style="color: #808080;">‚ö´ Gray</span> : 8</li>
                <li><span style="color: #000000;">‚ö´ Black</span> : 9</li>
                <li><span style="color: #00FFFF;">üü° Aqua</span> : a</li>
                <li><span style="color: #FF00FF;">üü£ Fuchsia</span> : b</li>
                <li><span style="color: #800000;">üü§ Maroon</span> : c</li>
                <li><span style="color: #808000;">üü§ Olive</span> : d</li>
                <li><span style="color: #008080;">üü¢ Teal</span> : e</li>
                <li><span style="color: #000080;">üîµ Navy</span> : f</li>
            </ul>
        </div>

        <!-- Spiral Visualization -->
        <div class="nft-container">
            <!-- SVG Spiral will be injected here by JavaScript -->
            <svg id="spiral-svg" width="500" height="500"></svg>
        </div>

        <!-- Connect Wallet Section -->
        <div id="walletSection">
            <button class="btn" id="connectButton">Connect Wallet</button>
            <button class="btn" id="disconnectButton" onclick="disconnectWallet()" disabled>Disconnect Wallet</button>
            <p id="walletAddress">Not connected</p>
        </div>

        <!-- Hash and Register Document -->
        <h3>Hash Your Media File</h3>
        <input type="file" id="fileInput" accept="image/*,video/*,audio/*,.pdf" /><br>
        <button class="btn" onclick="hashDocument()">Hash Document</button>

        <p id="hashOutput"></p>

        <!-- Color Code Mapping (Revealed After Hashing) -->
        <div id="colorCode" style="display: none; margin-top: 20px;">
            <h3>Color Code Mapping</h3>
            <ul style="list-style-type: none; padding-left: 0;">
                <li><span style="color: #FF0000;">üî¥ Red</span> : 0</li>
                <li><span style="color: #FFA500;">üü† Orange</span> : 1</li>
                <li><span style="color: #FFFF00;">üü° Yellow</span> : 2</li>
                <li><span style="color: #008000;">üü¢ Green</span> : 3</li>
                <li><span style="color: #0000FF;">üîµ Blue</span> : 4</li>
                <li><span style="color: #4B0082;">üü£ Indigo</span> : 5</li>
                <li><span style="color: #EE82EE;">üü£ Violet</span> : 6</li>
                <li><span style="color: #A52A2A;">üü§ Brown</span> : 7</li>
                <li><span style="color: #808080;">‚ö´ Gray</span> : 8</li>
                <li><span style="color: #000000;">‚ö´ Black</span> : 9</li>
                <li><span style="color: #00FFFF;">üü° Aqua</span> : a</li>
                <li><span style="color: #FF00FF;">üü£ Fuchsia</span> : b</li>
                <li><span style="color: #800000;">üü§ Maroon</span> : c</li>
                <li><span style="color: #808000;">üü§ Olive</span> : d</li>
                <li><span style="color: #008080;">üü¢ Teal</span> : e</li>
                <li><span style="color: #000080;">üîµ Navy</span> : f</li>
            </ul>
        </div>

        <button class="btn" id="registerButton" onclick="registerHashOnBlockchain()" disabled>
            Register Hash on Blockchain (Fee: <span id="buttonFee">0.01 ETH</span>)
        </button>
        <p id="feeNote">Note: A fee of <span id="feeAmount">0.01 ETH</span> is required to register your document.</p>

        <!-- Receipt -->
        <div id="receipt">
            <h3>Transaction Receipt</h3>
            <p id="receiptContent"></p>
        </div>
    </main>

    <!-- Loading Overlay -->
    <div id="loadingOverlay">
        <div class="loader"></div>
        <p>Please wait, your transaction is being processed. This may take a couple of minutes.</p>
    </div>

    <!-- Footer Section -->
    <footer>
        &copy; 2024 LockChain's MediaSecureNFT. All rights reserved.
    </footer>

    <!-- JavaScript for Functionality -->
    <script>
        let web3;
        let contract;
        let account;
        let hashHex;
        let provider;
        
        // Contract ABI (Replace with your actual complete ABI)
        const contractABI = [
          
        {
            "type": "constructor",
            "inputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "MINT_FEE",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "approve",
            "inputs": [
                {
                    "name": "to",
                    "type": "address",
                    "internalType": "address"
                },
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "balanceOf",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "internalType": "address"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "getApproved",
            "inputs": [
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "address"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "getMediaHash",
            "inputs": [
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "string",
                    "internalType": "string"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "isApprovedForAll",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "internalType": "address"
                },
                {
                    "name": "operator",
                    "type": "address",
                    "internalType": "address"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "bool",
                    "internalType": "bool"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "mintNFT",
            "inputs": [
                {
                    "name": "mediaHash",
                    "type": "string",
                    "internalType": "string"
                },
                {
                    "name": "tokenURI_",
                    "type": "string",
                    "internalType": "string"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "stateMutability": "payable"
        },
        {
            "type": "function",
            "name": "name",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "string",
                    "internalType": "string"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "owner",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "address"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "ownerOf",
            "inputs": [
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "address",
                    "internalType": "address"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "renounceOwnership",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "safeTransferFrom",
            "inputs": [
                {
                    "name": "from",
                    "type": "address",
                    "internalType": "address"
                },
                {
                    "name": "to",
                    "type": "address",
                    "internalType": "address"
                },
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "safeTransferFrom",
            "inputs": [
                {
                    "name": "from",
                    "type": "address",
                    "internalType": "address"
                },
                {
                    "name": "to",
                    "type": "address",
                    "internalType": "address"
                },
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "internalType": "uint256"
                },
                {
                    "name": "data",
                    "type": "bytes",
                    "internalType": "bytes"
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "setApprovalForAll",
            "inputs": [
                {
                    "name": "operator",
                    "type": "address",
                    "internalType": "address"
                },
                {
                    "name": "approved",
                    "type": "bool",
                    "internalType": "bool"
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "setMintFee",
            "inputs": [
                {
                    "name": "newFee",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "supportsInterface",
            "inputs": [
                {
                    "name": "interfaceId",
                    "type": "bytes4",
                    "internalType": "bytes4"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "bool",
                    "internalType": "bool"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "symbol",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "string",
                    "internalType": "string"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "tokenCounter",
            "inputs": [],
            "outputs": [
                {
                    "name": "",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "tokenURI",
            "inputs": [
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "outputs": [
                {
                    "name": "",
                    "type": "string",
                    "internalType": "string"
                }
            ],
            "stateMutability": "view"
        },
        {
            "type": "function",
            "name": "transferFrom",
            "inputs": [
                {
                    "name": "from",
                    "type": "address",
                    "internalType": "address"
                },
                {
                    "name": "to",
                    "type": "address",
                    "internalType": "address"
                },
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "transferOwnership",
            "inputs": [
                {
                    "name": "newOwner",
                    "type": "address",
                    "internalType": "address"
                }
            ],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "function",
            "name": "withdraw",
            "inputs": [],
            "outputs": [],
            "stateMutability": "nonpayable"
        },
        {
            "type": "event",
            "name": "Approval",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "approved",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "indexed": true,
                    "internalType": "uint256"
                }
            ],
            "anonymous": false
        },
        {
            "type": "event",
            "name": "ApprovalForAll",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "operator",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "approved",
                    "type": "bool",
                    "indexed": false,
                    "internalType": "bool"
                }
            ],
            "anonymous": false
        },
        {
            "type": "event",
            "name": "BatchMetadataUpdate",
            "inputs": [
                {
                    "name": "_fromTokenId",
                    "type": "uint256",
                    "indexed": false,
                    "internalType": "uint256"
                },
                {
                    "name": "_toTokenId",
                    "type": "uint256",
                    "indexed": false,
                    "internalType": "uint256"
                }
            ],
            "anonymous": false
        },
        {
            "type": "event",
            "name": "MetadataUpdate",
            "inputs": [
                {
                    "name": "_tokenId",
                    "type": "uint256",
                    "indexed": false,
                    "internalType": "uint256"
                }
            ],
            "anonymous": false
        },
        {
            "type": "event",
            "name": "MintFeeUpdated",
            "inputs": [
                {
                    "name": "oldFee",
                    "type": "uint256",
                    "indexed": false,
                    "internalType": "uint256"
                },
                {
                    "name": "newFee",
                    "type": "uint256",
                    "indexed": false,
                    "internalType": "uint256"
                }
            ],
            "anonymous": false
        },
        {
            "type": "event",
            "name": "NFTMinted",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "indexed": true,
                    "internalType": "uint256"
                },
                {
                    "name": "mediaHash",
                    "type": "string",
                    "indexed": false,
                    "internalType": "string"
                },
                {
                    "name": "tokenURI",
                    "type": "string",
                    "indexed": false,
                    "internalType": "string"
                }
            ],
            "anonymous": false
        },
        {
            "type": "event",
            "name": "OwnershipTransferred",
            "inputs": [
                {
                    "name": "previousOwner",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "newOwner",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                }
            ],
            "anonymous": false
        },
        {
            "type": "event",
            "name": "Transfer",
            "inputs": [
                {
                    "name": "from",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "to",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "indexed": true,
                    "internalType": "uint256"
                }
            ],
            "anonymous": false
        },
        {
            "type": "event",
            "name": "Withdrawal",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "indexed": true,
                    "internalType": "address"
                },
                {
                    "name": "amount",
                    "type": "uint256",
                    "indexed": false,
                    "internalType": "uint256"
                }
            ],
            "anonymous": false
        },
        {
            "type": "error",
            "name": "ERC721IncorrectOwner",
            "inputs": [
                {
                    "name": "sender",
                    "type": "address",
                    "internalType": "address"
                },
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "internalType": "uint256"
                },
                {
                    "name": "owner",
                    "type": "address",
                    "internalType": "address"
                }
            ]
        },
        {
            "type": "error",
            "name": "ERC721InsufficientApproval",
            "inputs": [
                {
                    "name": "operator",
                    "type": "address",
                    "internalType": "address"
                },
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ]
        },
        {
            "type": "error",
            "name": "ERC721InvalidApprover",
            "inputs": [
                {
                    "name": "approver",
                    "type": "address",
                    "internalType": "address"
                }
            ]
        },
        {
            "type": "error",
            "name": "ERC721InvalidOperator",
            "inputs": [
                {
                    "name": "operator",
                    "type": "address",
                    "internalType": "address"
                }
            ]
        },
        {
            "type": "error",
            "name": "ERC721InvalidOwner",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "internalType": "address"
                }
            ]
        },
        {
            "type": "error",
            "name": "ERC721InvalidReceiver",
            "inputs": [
                {
                    "name": "receiver",
                    "type": "address",
                    "internalType": "address"
                }
            ]
        },
        {
            "type": "error",
            "name": "ERC721InvalidSender",
            "inputs": [
                {
                    "name": "sender",
                    "type": "address",
                    "internalType": "address"
                }
            ]
        },
        {
            "type": "error",
            "name": "ERC721NonexistentToken",
            "inputs": [
                {
                    "name": "tokenId",
                    "type": "uint256",
                    "internalType": "uint256"
                }
            ]
        },
        {
            "type": "error",
            "name": "OwnableInvalidOwner",
            "inputs": [
                {
                    "name": "owner",
                    "type": "address",
                    "internalType": "address"
                }
            ]
        },
        {
            "type": "error",
            "name": "OwnableUnauthorizedAccount",
            "inputs": [
                {
                    "name": "account",
                    "type": "address",
                    "internalType": "address"
                }
            ]
        }
    ]
}

       
      // Contract address (Replace with your deployed contract address)
        const contractAddress = '0x26E5D85e4E8f381558cDccAb4BDae80bd4a9cEB1';

            // Initialize Web3Modal
        const providerOptions = {
            walletconnect: {
                package: window.WalletConnectProvider.default,
                options: {
                    rpc: {
                        11155111: "https://eth-sepolia.alchemyapi.io/v2/DlloOg9phVabjuMziEUxAdV1a2veqPNU" // Sepolia via Alchemy
                    }
                }
            },
            coinbasewallet: {
                package: window.CoinbaseWalletSDK.default, // Required
                options: {
                    appName: "MediaSecureNFT", // Required
                    rpc: "https://eth-sepolia.alchemyapi.io/v2/DlloOg9phVabjuMziEUxAdV1a2veqPNU", // Sepolia via Alchemy
                    chainId: 11155111, // Sepolia Test Network ID
                    darkMode: false // Optional. Use dark theme?
                }
            }
        };

        const web3Modal = new window.Web3Modal.default({
            cacheProvider: false, // Prevents automatic reconnections
            providerOptions, // Required
        });

       

        // Add event listener to the Connect Wallet button
        document.getElementById('connectButton').addEventListener('click', connectWallet);

     // Function to connect wallet using Web3Modal
       async function connectWallet() {
    if (window.ethereum) {
        try {
            console.log('Requesting account access...');
            // Request account access if needed
            await window.ethereum.request({ method: 'eth_requestAccounts' });
            web3 = new Web3(window.ethereum);
            const accounts = await web3.eth.getAccounts();
            account = accounts[0];
            document.getElementById('walletAddress').innerText = 'Connected: ' + account;
            contract = new web3.eth.Contract(contractABI, contractAddress);
            console.log('Connected account:', account);
        } catch (error) {
            console.error('Error connecting to MetaMask:', error);
            alert('Error connecting to MetaMask.');
        }
    } else {
        alert('Please install MetaMask!');
    }
}

        // Function to disconnect wallet
        function disconnectWallet() {
            if (provider && provider.close) {
                provider.close();
            }
            web3Modal.clearCachedProvider();
            account = null;
            contract = null;
            document.getElementById('walletAddress').innerText = 'Not connected';
            document.getElementById('disconnectButton').disabled = true;
            document.getElementById('connectButton').disabled = false;
            document.getElementById('registerButton').disabled = true;
            document.getElementById('hashOutput').innerText = '';
            document.getElementById('receipt').style.display = 'none';
            // Clear any stored hash
            hashHex = null;
            // Hide the color code mapping
            document.getElementById('colorCode').style.display = 'none';
            alert('Wallet has been disconnected.');
        }

        // Function to fetch and display the current fee
        async function displayCurrentFee() {
            try {
                const feeInWei = await contract.methods.MINT_FEE().call();
                console.log('Fetched fee in Wei:', feeInWei);
                const feeInEth = web3.utils.fromWei(feeInWei, 'ether');
                console.log('Converted fee to ETH:', feeInEth);
                document.getElementById('buttonFee').innerText = feeInEth + ' ETH';
                document.getElementById('feeAmount').innerText = feeInEth + ' ETH'; // Update feeAmount
            } catch (error) {
                console.error('Error fetching current fee:', error);
                alert('Error fetching current fee from the contract. Check console for details.');
            }
        }

        // Function to hash the selected media file
        async function hashDocument() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a media file.');
                return;
            }

            try {
                const arrayBuffer = await file.arrayBuffer();
                const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                hashHex = '0x' + hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                document.getElementById('hashOutput').innerText = `Document Hash: ${hashHex}`;

                // Enable the register button
                document.getElementById('registerButton').disabled = false;

                // Generate the spiral visualization
                generateSpiral(hashHex.slice(2)); // Remove '0x' prefix

                // Reveal the color code mapping
                document.getElementById('colorCode').style.display = 'block';
            } catch (error) {
                console.error('Error hashing the document:', error);
                alert('Error hashing the document. See console for details.');
            }
        }

        // Function to upload metadata to IPFS via backend server
        async function uploadMetadataToIPFS(metadataBlob) {
            const formData = new FormData();
            formData.append('file', metadataBlob, `metadata_${Date.now()}.json`);

            try {
                const response = await fetch('http://localhost:3000/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error('Failed to upload metadata to IPFS.');
                }

                const data = await response.json();
                return data.IpfsHash;
            } catch (error) {
                console.error('Error uploading metadata to IPFS:', error);
                throw error;
            }
        }

        // Function to register the hashed document on the blockchain
        async function registerHashOnBlockchain() {
            if (!web3 || !account) {
                alert('Please connect your wallet first.');
                return;
            }

            if (!hashHex) {
                alert('Please hash a media file first.');
                return;
            }

            const mediaHash = hashHex;

            // Generate the spiral SVG Data URI
            const svgDataURI = generateSpiral(mediaHash.slice(2)); // Remove '0x' prefix

            // Create the JSON metadata
            const metadata = {
                name: `MediaSecureNFT #${Date.now()}`, // Unique name, e.g., based on timestamp
                description: "An NFT representing a secure media file with a unique spiral fingerprint.",
                image: svgDataURI // Embed the spiral SVG directly
            };

            // Convert metadata to Blob
            const metadataBlob = new Blob([JSON.stringify(metadata)], { type: 'application/json' });

            try {
                // Fetch the current fee from the contract
                const feeInWei = await contract.methods.MINT_FEE().call();
                console.log('Fee in Wei:', feeInWei);

                // Show the loading overlay
                document.getElementById('loadingOverlay').style.display = 'flex';

                // Upload the metadata JSON to your backend server
                const ipfsHash = await uploadMetadataToIPFS(metadataBlob);

                if (!ipfsHash) {
                    throw new Error('Failed to upload metadata to IPFS.');
                }

                const tokenURI = `https://gateway.pinata.cloud/ipfs/${ipfsHash}`;

                // Send the transaction to mintNFT with tokenURI
                const receipt = await contract.methods.mintNFT(mediaHash, tokenURI).send({
                    from: account,
                    value: feeInWei, // Use the dynamic fee
                });

                console.log('Transaction receipt:', receipt);
                generateReceipt(mediaHash, account, receipt);
            } catch (error) {
                console.error('Error registering hash on blockchain:', error);
                alert('Error registering hash on blockchain. See console for details.');
            } finally {
                // Hide the loading overlay
                document.getElementById('loadingOverlay').style.display = 'none';
            }
        }

        // Function to generate and display the transaction receipt
        function generateReceipt(mediaHash, account, receipt) {
            let tokenId = null;

            // Iterate through the logs to find the Transfer event
            if (receipt.events && receipt.events.Transfer && receipt.events.Transfer.returnValues) {
                tokenId = receipt.events.Transfer.returnValues.tokenId;
            }

            if (!tokenId) {
                // If Transfer event is not found in receipt, alert the user
                alert('Transaction successful, but could not retrieve Token ID.');
                return;
            }

            // Construct the Etherscan link for the NFT
            const etherscanLink = `https://sepolia.etherscan.io/token/${contractAddress}?a=${tokenId}`;

            const timestamp = new Date().toLocaleString();
            const receiptContent = `
                <strong>Document Hash:</strong> ${mediaHash}<br>
                <strong>Registered By:</strong> ${account}<br>
                <strong>Date and Time:</strong> ${timestamp}<br>
                <strong>Token ID:</strong> ${tokenId}<br>
                <strong>View Your NFT:</strong> <a href="${etherscanLink}" target="_blank">Etherscan Link</a>
            `;
            document.getElementById('receiptContent').innerHTML = receiptContent;
            document.getElementById('receipt').style.display = 'block';
        }

        // Function to generate the spiral visualization based on the hash
        function generateSpiral(hash) {
            const svg = document.getElementById('spiral-svg');
            svg.innerHTML = ''; // Clear previous spiral
            const xmlns = "http://www.w3.org/2000/svg";
            const centerX = svg.clientWidth / 2; // SVG center X
            const centerY = svg.clientHeight / 2; // SVG center Y

            // Spiral parameters adjusted to keep spiral within the circle
            const a = 4.5; // Controls the distance between loops
            const b = 0.12; // Controls the tightness of the spiral
            const numPoints = hash.length;
            const angleIncrement = 0.5; // Radians between points

            // Color mapping for hexadecimal characters (0-9, a-f)
            const digitColors = {
                '0': '#FF0000', // Red
                '1': '#FFA500', // Orange
                '2': '#FFFF00', // Yellow
                '3': '#008000', // Green
                '4': '#0000FF', // Blue
                '5': '#4B0082', // Indigo
                '6': '#EE82EE', // Violet
                '7': '#A52A2A', // Brown
                '8': '#808080', // Gray
                '9': '#000000', // Black
                'a': '#00FFFF', // Aqua
                'b': '#FF00FF', // Fuchsia
                'c': '#800000', // Maroon
                'd': '#808000', // Olive
                'e': '#008080', // Teal
                'f': '#000080'  // Navy
            };

            // Arrays to store points for connecting lines
            const points = [];

            // Iterate over each character in the hash
            for (let i = 0; i < numPoints; i++) {
                const char = hash[i].toLowerCase(); // Ensure lowercase for a-f
                if (!digitColors[char]) continue; // Skip if not a valid hex character

                // Invert theta to change spiral direction to clockwise
                const theta = -i * angleIncrement;
                const r = a * Math.exp(b * Math.abs(theta)); // Use absolute value to ensure r is positive

                // Convert polar to cartesian coordinates
                let x = centerX + r * Math.cos(theta);
                let y = centerY + r * Math.sin(theta);

                // Ensure the point stays within the circle
                const maxRadius = (svg.clientWidth / 2) - 20; // 20px padding
                const currentRadius = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                if (currentRadius > maxRadius) {
                    // Scale down the point proportionally
                    const scale = maxRadius / currentRadius;
                    x = centerX + (x - centerX) * scale;
                    y = centerY + (y - centerY) * scale;
                }

                // Store the point for connecting lines
                points.push({ x, y });

                // Create a larger circle for each hex character (increased radius from 5 to 8)
                const circle = document.createElementNS(xmlns, "circle");
                circle.setAttribute("cx", x);
                circle.setAttribute("cy", y);
                circle.setAttribute("r", 8); // Increased radius
                circle.setAttribute("fill", digitColors[char]);

                svg.appendChild(circle);
            }

            // Draw curved connecting lines between points to mimic fingerprint ridges
            for (let i = 0; i < points.length - 1; i++) {
                const start = points[i];
                const end = points[i + 1];

                // Calculate control points for Bezier curves
                // Adjusting control points to enhance clockwise curvature
                const controlPoint1 = {
                    x: start.x + (end.x - start.x) / 2 + 10, // Shift control points to the right
                    y: start.y - 20 // Adjust for curvature
                };
                const controlPoint2 = {
                    x: start.x + (end.x - start.x) / 2 + 10, // Shift control points to the right
                    y: end.y - 20 // Adjust for curvature
                };

                // Create a path for the Bezier curve
                const path = document.createElementNS(xmlns, "path");
                const d = `M ${start.x} ${start.y} C ${controlPoint1.x} ${controlPoint1.y}, ${controlPoint2.x} ${controlPoint2.y}, ${end.x} ${end.y}`;
                path.setAttribute("d", d);
                path.setAttribute("stroke", digitColors[hash[i + 1].toLowerCase()] || '#000000');
                path.setAttribute("stroke-width", "2");
                path.setAttribute("fill", "none");
                path.setAttribute("opacity", "0.6");

                svg.appendChild(path);
            }

            // Serialize the SVG to a string
            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(svg);

            // Encode the SVG string to Base64
            const svgBase64 = btoa(unescape(encodeURIComponent(svgString)));

            // Create the Data URI
            const svgDataURI = `data:image/svg+xml;base64,${svgBase64}`;

            return svgDataURI; // Return the Data URI for further use
        }

        // Function to upload metadata to IPFS via backend server
        async function uploadMetadataToIPFS(metadataBlob) {
            const formData = new FormData();
            formData.append('file', metadataBlob, `metadata_${Date.now()}.json`);

            try {
                const response = await fetch('http://localhost:3000/upload', { // Update with your backend URL
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error('Failed to upload metadata to IPFS.');
                }

                const data = await response.json();
                return data.IpfsHash;
            } catch (error) {
                console.error('Error uploading metadata to IPFS:', error);
                throw error;
            }
        }

        // Function to register the hashed document on the blockchain
        async function registerHashOnBlockchain() {
            if (!web3 || !account) {
                alert('Please connect your wallet first.');
                return;
            }

            if (!hashHex) {
                alert('Please hash a media file first.');
                return;
            }

            const mediaHash = hashHex;

            // Generate the spiral SVG Data URI
            const svgDataURI = generateSpiral(mediaHash.slice(2)); // Remove '0x' prefix

            // Create the JSON metadata
            const metadata = {
                name: `MediaSecureNFT #${Date.now()}`, // Unique name, e.g., based on timestamp
                description: "An NFT representing a secure media file with a unique spiral fingerprint.",
                image: svgDataURI // Embed the spiral SVG directly
            };

            // Convert metadata to Blob
            const metadataBlob = new Blob([JSON.stringify(metadata)], { type: 'application/json' });

            try {
                // Fetch the current fee from the contract
                const feeInWei = await contract.methods.MINT_FEE().call();
                console.log('Fee in Wei:', feeInWei);

                // Show the loading overlay
                document.getElementById('loadingOverlay').style.display = 'flex';

                // Upload the metadata JSON to your backend server
                const ipfsHash = await uploadMetadataToIPFS(metadataBlob);

                if (!ipfsHash) {
                    throw new Error('Failed to upload metadata to IPFS.');
                }

                const tokenURI = `https://gateway.pinata.cloud/ipfs/${ipfsHash}`;

                // Send the transaction to mintNFT with tokenURI
                const receipt = await contract.methods.mintNFT(mediaHash, tokenURI).send({
                    from: account,
                    value: feeInWei, // Use the dynamic fee
                });

                console.log('Transaction receipt:', receipt);
                generateReceipt(mediaHash, account, receipt);
            } catch (error) {
                console.error('Error registering hash on blockchain:', error);
                alert('Error registering hash on blockchain. See console for details.');
            } finally {
                // Hide the loading overlay
                document.getElementById('loadingOverlay').style.display = 'none';
            }
        }

        // Function to generate and display the transaction receipt
        function generateReceipt(mediaHash, account, receipt) {
            let tokenId = null;

            // Iterate through the logs to find the Transfer event
            if (receipt.events && receipt.events.Transfer && receipt.events.Transfer.returnValues) {
                tokenId = receipt.events.Transfer.returnValues.tokenId;
            }

            if (!tokenId) {
                // If Transfer event is not found in receipt, alert the user
                alert('Transaction successful, but could not retrieve Token ID.');
                return;
            }

            // Construct the Etherscan link for the NFT
            const etherscanLink = `https://sepolia.etherscan.io/token/${contractAddress}?a=${tokenId}`;

            const timestamp = new Date().toLocaleString();
            const receiptContent = `
                <strong>Document Hash:</strong> ${mediaHash}<br>
                <strong>Registered By:</strong> ${account}<br>
                <strong>Date and Time:</strong> ${timestamp}<br>
                <strong>Token ID:</strong> ${tokenId}<br>
                <strong>View Your NFT:</strong> <a href="${etherscanLink}" target="_blank">Etherscan Link</a>
            `;
            document.getElementById('receiptContent').innerHTML = receiptContent;
            document.getElementById('receipt').style.display = 'block';
        }

    </script>

</body>
</html>
